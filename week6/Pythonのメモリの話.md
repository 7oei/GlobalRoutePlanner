# Pythonのメモリの話
## 2020/06/23
STEPで習ったのでせっかくだしまとめて書いておきます。
## 値渡しと参照渡し
- 値渡し
	-  関数を呼び出す時に仮引数に指定した値をコピーして実引数に渡す
	-  呼び出し元の変数の値には影響が出ない
- 参照渡し
	- 関数を呼び出す時に仮引数に指定した値が保管されている場所の情報を実引数に渡す
	- 関数内で変数の値を変更すると呼び出し元の変数が参照している値も変更される

<br>
**引数に数値や文字列などのイミュータブルなオブジェクトを指定した場合**<br>

-  参照渡し
- ただイミュータブルなオブジェクトは作成された後で値を変更することができない
- 関数内で実引数を代入された変数に変更が加えられて新しい値が代入されると、別の保管場所に新しい値を保存した上でその場所を参照するようになる
- 参照渡しであっても引数にイミュータブルな値を指定した場合には**値渡しのような挙動**となる

**引数にリストや辞書などのミュータブルなオブジェクトを指定した場合**<br> 

- 参照渡し
- ミュータブルなオブジェクトはあとから要素の値などを変更可能
- 関数内で実引数を代入された変数に変更が加えられると、現在の保管場所に保管されている値が変更されるため、関数の呼び出し元の変数が参照している値も変更
- **参照渡しそのものの挙動**

## Q1
```py
a=1
b=a
b=2

print('a:',a,id(a)) # a: 1 4310218192
print('b:',b,id(b)) # b: 2 4310218224
```

- aとbは別々の場所にメモリ確保

## Q2
~~~py
a=[1]
b=a
b.append(2)

print('a:',a,id(a)) # a: [1, 2] 4443823944
print('b:',b,id(b)) # b: [1, 2] 4443823944
~~~
- 関数呼び出しは参照渡し
- ミュータブルなオブジェクトは参照私そのものの挙動
- 元の変数も変更される

## Q3
```py
def foo(b):
  b=2
  print('b:',b,id(b)) 

a=1
print('a:',a,id(a)) # a: 1 4444206544
foo(a) # b: 2 4451673584

print('a:',a,id(a)) # a: 1 4444206544
```
- イミュータブル
- 値渡しのような挙動
- aのアドレスとは別のアドレスに1がコピーされて保存され、その値が関数fooによって変更される


## Q4
```py
def foo(b):
  b.append(2)
  print('b:',b,id(b))

a=[1]
print('a:',a,id(a)) # a: [1] 4368219976
foo(a)  # b: [1, 2] 4368219976

print('a:',a,id(a)) # a: [1, 2] 4368219976
```
- リストはミュータブル
- 参照渡しそのものの挙動
- bの参照場所にはaの参照場所が保存される -> bを変更するとそれに伴いaも変更

## Q4.5
Q5をやる前にQ4.5としてリストの連結操作を確認

```py
def foo(b):
  print('b:',b,id(b)) # b: [1] 4339265352
  b=b+[3]
  print('b:',b,id(b)) # b: [1, 3] 4341457736

a=[1]
print('a:',a,id(a)) # a: [1] 4339265352
foo(a) 
print('a:',a,id(a)) # a: [1] 4339265352
```
- 関数の引数として渡した時点ではミュータブルなリストを渡しただけだから参照渡しの挙動
- リスト連結操作をすると別のメモリ確保してそこに保存
- 挙動的には値渡しとなり、これ以降参照元のリストは変更されなくなる

## Q5
### これのメモリの使われ方を調べるのが宿題
```py
def foo(b):
  b.append(2) # b: [1, 2] 4425707336
  print('b:',b,id(b))
  b=b+[3] # b: [1, 2, 3] 4427899912
  print('b:',b,id(b))
  b.append(4) # b: [1, 2, 3, 4] 4427899912
  print('b:',b,id(b))

a=[1]
print('a:',a,id(a)) # a: [1] 4425707336
foo(a)
print('a:',a,id(a)) # a: [1, 2] 4425707336
```
- リストはミュータブルなので最初は参照渡しそのものの挙動を示す
- 参照元のaもそれに伴い変更される
- ```b=b+[3]```の操作でbは別のメモリに格納され、3をappendした新しい配列となる
- ここで別のメモリにコピーされてしまうので挙動としては値渡しとなる
- そのためこれ以降のbの変更はaには反映されない
 
**リストの連結操作の前までは参照渡しの挙動、その後は値渡しの挙動**


## 文字列リストの参照渡しの例
```py
def foo(x):
  print('id(x): %#08x' % id(x))

a = ['hello', 'world']
print('id(a): %#08x' % id(a))

foo(a)

# id(a): 0x106f75f48
# id(x): 0x106f75f48
```